from langchain_core.tools import tool

from echos_lab.engines import follow_user, post_maker, post_retriever, agent_interests, context_store
from echos_lab.twitter_lib import twitter_pipeline, twitter_connector
from echos_lab.crypto_lib import crypto_connector
from echos_lab.db import db_setup
from echos_lab.telegram_lib import telegram_connector
import traceback
import time
from typing import List


ACCOUNT = twitter_connector.get_twitter_account()
SCRAPER = twitter_connector.get_twitter_scraper()

DB = db_setup.get_db_session()


def send_tg_message_wrapper(contents, chat_id=telegram_connector.TARGET_CHAT_ID):
    telegram_connector.send_message_sync(contents, chat_id=chat_id)
    return True


@tool
def construct_viral_tweet(subject_matter: str, sentiment: str, replying_to: str) -> str:
    """
    Generates an edgy tweet based on the given subject matter.

    You should use this tool to generate a tweet that is clever, witty, and likely to get attention.

    Do NOT modify the tweet content generated by this tool.
    The tweet content is designed to be provocative and engaging.

    Any modifications to the output of these tweets should be done very intentionally, and extremely carefully.

    Please take the output of this tool, and directly send it to telegram or Twitter, WITHOUT CHANGES.
    Whenever you use this tool, you must ALSO send the output in Telegram or Twitter.

    The subject matter should describe the kind of tweet you want to generate.
    If you want to make a tweet about a certain coin, you MUST pass in the ticker of the coin in the subject matter.
    This tool does NOT know what coins you hold, so you must tell it what coin you wnat to tweet about.

    If you want to respond to or quote tweet someone else, you NEED to pass that content of that tweet in "replying_to".

    Pass in "positive", "neutral", or "negative" for the sentiment parameter, and the tweet will have that tone.

    Parameters:
    - subject_matter (str): A short textual description of the kind of tweet you want to generate.
    - sentiment (str): The sentiment of the tweet. Can be "positive", "neutral", or "negative".
    - replying_to (str): The content of the tweet you want to respond to. If not applicable, pass in an empty string.

    Returns:
    - str: The generated tweet content.
    """
    new_tweet = post_maker.generate_tweet_from_model(sentiment, subject_matter, replying_to)
    return new_tweet


@tool
def send_tweet(tweet_content: str) -> bool:
    """
    Post a new tweet on your Twitter account.
    The exact contents of "tweet_contents" will be posted as a new tweet.

    Parameters:
    - tweet_content (str): The content of the tweet to post

    Returns:
    - bool: True if the tweet was successfully posted, False otherwise
    """
    return send_tg_message_wrapper(f"TWEET\n{tweet_content}", chat_id=context_store.get_env_var("chat_id"))


@tool
def send_tweet_reply(tweet_content: str, tweet_id: str, user_name: str) -> bool:
    """
    Post a reply to an existing tweet, with given tweet_id.

    You should ONLY use this when trying to reply to someone on Twitter, not when you're
    just replying to someone on Telegram. If you're casually chatting with someone on Telegram,
    and they didn't explicit ask you to reply to a tweet, use the "send_telegram_message" tool instead.

    The exact contents of "tweet_contents" will be posted as a reply.

    Parameters:
    - tweet_content (str): The content of the reply to post
    - tweet_id (str): The ID of the tweet to reply to
    - user_name (str): The username of the user who we're replying to

    Returns:
    - bool: True if the tweet was successfully posted, False otherwise
    """
    twitter_url = f"https://twitter.com/{user_name}/status/{tweet_id}"
    new_message = f"[{telegram_connector.REPLY_TWEET_MARKER}]({twitter_url})\n{tweet_content}"
    return send_tg_message_wrapper(new_message, chat_id=context_store.get_env_var("chat_id"))


@tool
def send_quote_tweet(tweet_content: str, tweet_id: str, user_name: str) -> bool:
    """
    Post a quote tweet to an existing tweet, with given tweet_id.

    The exact contents of "tweet_contents" will be posted as a quote tweet.

    Parameters:
    - tweet_content (str): The content of the tweet to post
    - tweet_id (str): The ID of the tweet to quote tweet to
    - user_name (str): The username of the user who we're quoting

    Returns:
    - bool: True if the tweet was successfully posted, False otherwise
    """
    twitter_url = f"https://twitter.com/{user_name}/status/{tweet_id}"
    new_message = f"[{telegram_connector.QUOTE_TWEET_MARKER}]({twitter_url})\n{tweet_content}"
    return send_tg_message_wrapper(new_message, chat_id=context_store.get_env_var("chat_id"))


def get_twitter_feed_raw(new_posts_only: bool, include_id=True, notifications_only=False) -> str:
    # get recent tweets
    recent_posts, formatted_recent_posts, notif_context_tuple = twitter_pipeline.get_recent_tweets(
        db=DB,
        account=ACCOUNT,
        scraper=SCRAPER,
        notifications_only=notifications_only,
    )
    # update our db with tweet ids
    filtered_notif_context_tuple = twitter_pipeline.update_db_with_tweet_ids(
        db=DB,
        notif_context_tuple=notif_context_tuple,
    )
    relevant_tweets = notif_context_tuple
    # get what tweets we've already talked about in TG
    seen_ids = telegram_connector.get_interacted_tweets()
    # format the tweets
    if new_posts_only:
        relevant_tweets = filtered_notif_context_tuple
    post_str = "TWEETS\n====================\n"
    for tweet in relevant_tweets:
        post_str += f"{tweet[0].strip()}\n"
        if include_id:
            post_str += f"\tTweet ID: {tweet[1]}\n"
        if tweet[1] in seen_ids:
            post_str += "\t[YOU ALREADY RESPONDED TO THIS]\n"
        post_str += "---\n"
    post_str += "====================\n"

    return post_str


@tool
def get_twitter_feed() -> str:
    """
    Get the most recent tweets on your Twitter feed.

    This returns a detailed text description of the most recent tweets on your feed.
    The output includes post IDs, usernames, and the content of the tweets.

    Returns:
    - str: A detailed text description of the most recent tweets on your feed.
           Output includes post IDs, usernames, and the content of the tweets.
    """
    return get_twitter_feed_raw(new_posts_only=False)


@tool
def get_twitter_notifications() -> str:
    """
    Gets your most recent notifications on Twitter.

    This returns a detailed text description of the most recent notifications you have on Twitter.

    You should take special care to respond to anyone that tags you.
    If someone tags you, you need to "reply tweet" or "quote tweet" it!

    Returns:
    - str: A detailed text description of your notifications
           Output includes post IDs, usernames, and the content of the tweets.
    """
    return get_twitter_feed_raw(new_posts_only=True, notifications_only=True)


@tool
def get_twitter_post(post_id: str) -> str:
    """
    Gets the contents of a specific post on Twitter, including the relevant thread.

    This will return the creator of the tweets in the thread, the content of the tweets, and the post IDs.

    Please note: this takes post_id, NOT post_url.

    Parameters:
    - post_id (str): an id of a tweet, e.g. 1853495774061187475

    Returns:
    - str: A detailed text description of the post and surrounding conversation
    """
    for _ in range(3):
        try:
            formatted_text = post_retriever.format_conversation_for_llm({}, post_id, SCRAPER, individual_tweet=True)
            return formatted_text
        except Exception:
            traceback.print_exc()
            print(f"Trying again to fetch tweet {post_id}")
            time.sleep(3)
    return "Error fetching tweet."


@tool
def read_twitter_user_posts(username: str) -> str:
    """
    Returns the most recent tweets for a particular username.

    This will return a well-formatted string containing the most recent tweets for the specified username.

    Please note: this takes a username, e.g. "jack"

    Parameters:
    - username (str): a Twitter username, e.g. "jack"

    Returns:
    - str: A text block containing the most recent tweets for the specified username
    """
    twitter_posts = twitter_connector.get_tweets_from_user(username)
    return twitter_posts


@tool
def like_twitter_post(post_id: str) -> bool:
    """
    Likes the specified Twitter post by its ID. Can only like one post at a time.

    For example, to like the post with ID 1234567890, you would call like_twitter_post("1234567890")

    Parameters:
    - post_id (str): The ID of the Twitter post to like

    Returns:
    - bool: True if the post was successfully liked, False otherwise
    """
    out = follow_user.like_post(ACCOUNT, post_id)
    try:
        if out['data']['favorite_tweet'] == 'Done':
            return True
    except KeyError:
        pass
    return False


@tool
def follow_twitter_user(username: str) -> bool:
    """
    Follows the specified Twitter User by their username.

    For example, to follow the user @jack, you would call follow_twitter_user("jack")

    Parameters:
    - username (str): The username of the Twitter user to follow

    Returns:
    - bool: True if the user was successfully followed, False otherwise
    """
    target = twitter_connector.get_user_id(username=username)
    if target:
        out = follow_user.follow_user(ACCOUNT, target)
        print(out)
        return True
    return False


def get_telegram_messages_raw(specific_user: str = "", chat_id: int = telegram_connector.TARGET_CHAT_ID) -> str:
    messages = telegram_connector.get_most_recent_messages(target_chat_id=chat_id)
    message_str = "TELEGRAM MESSAGES\n====================\n"
    for msg in messages:
        message_str += '---\n'
        if specific_user != "":
            if msg[0] == specific_user:
                message_str += f"\t{msg[1]}\n\tFrom: {msg[0]}\n"
        else:
            message_str += f"\t{msg[1]}\n\tFrom: {msg[0]}\n"
    message_str += "====================\n"
    return message_str


@tool
def get_telegram_messages() -> str:
    """
    Fetches the most recent messages from your Telegram group chat.

    This tool retrieves the most recent messages from your Telegram account.
    The messages are returned as a formatted text string.

    The oldest message is at the top, and the most recent message is at the bottom.

    Returns:
    - str: A formatted text string containing the most recent messages from your Telegram account.
    """
    return get_telegram_messages_raw(chat_id=context_store.get_env_var("chat_id"))


@tool
def get_interacted_tweets() -> List[str]:
    """
    Fetches a list of tweet IDs that you have already interacted with, e.g. Quote Tweet / Replied to.

    You should ALWAYS use this tool to verify that you're not interacting with the same tweet multiple times.

    Do NOT Quote Tweet / Reply / etc again, unless you're explicitly asked to in Telegram.

    Returns:
    - List[str]: A list of strings, representing tweet IDs that you have already interacted with.
    """
    return telegram_connector.get_interacted_tweets()


@tool
def send_telegram_message(message_content: str) -> bool:
    """
    Post a new message to your private Telegram channel.

    Parameters:
    - message_content (str): The content of the message to send

    Returns:
    - bool: True if the message was successfully sent, False otherwise
    """
    return send_tg_message_wrapper(message_content, chat_id=context_store.get_env_var("chat_id"))


@tool
def construct_specialized_llm_tweet(
    mode: str,
    respond_to: str,
) -> str:
    """
    Uses a specialized LLM to generate a tweet based on the given subject matter.

    Only use this if you want to generate a high-quality tweet, but don't use this if you're talking to your buddies.

    You should use this tool to generate a tweet that is clever, witty, and likely to get attention.

    Do NOT modify the tweet content generated by this tool.
    The tweet content is designed to be provocative and engaging.

    Any modifications to the output of these tweets should be done very intentionally, and extremely carefully.

    Please take the output of this tool, and directly send it to telegram or Twitter, WITHOUT CHANGES.

    You need pass in a mode, one of either "response", "tweet", or "timeline".
    - Use "response" to respond to a specific tweet.
    - Use "tweet" to generate a free form tweet
    - Use "timeline" to generate a tweet based on your timeline

    If you're trying to respond to someone else, or quote tweet someone, you NEED to pass in "mode=response".
    You then NEED to pass in the tweet you're responding to in "respond_to". If not, the tweet will not be topical.

    Parameters:
    - mode (str): One of "response", "tweet", or "timeline".
    - respond_to (str): A string containing the tweet you want to respond to.
    If you're not responding to a tweet, pass in "No tweet to respond to."

    Returns:
    - str: The generated tweet content.
    """
    if mode == "timeline":
        timeline = get_twitter_feed_raw(new_posts_only=False, include_id=False)
    else:
        timeline = ""
    recent_messages = get_telegram_messages_raw(specific_user="You", chat_id=context_store.get_env_var("chat_id"))
    recent_messages = recent_messages.replace("TELEGRAM MESSAGES\n====================\n", "")
    new_tweet = post_maker.generate_tweet_from_model_hal(mode, recent_messages, timeline, respond_to=respond_to)
    return new_tweet


@tool
def get_crypto_balance() -> str:
    """
    Fetches your account's crypto holdings.

    Your holdings are returned as a well-formatted string describing the
    assets you hold, their tickers, and their current value.

    Returns:
    - str: A formatted text string containing your crypto holdings.
    """
    crypto_balance = crypto_connector.query_self_account_balance()
    formatted_balance = crypto_connector.format_balances(crypto_balance)
    return formatted_balance


@tool
def launch_memecoin(name: str, symbol: str, description: str, image_description: str) -> bool:
    """
    Launches a memecoin with the given name, symbol, and description.
    This has real-world consequences, so make sure you really want to launch a coin when you use this.

    An example of a call to this function would be:
        name: "DogeCoin"
        symbol: "DOGE"
        description: "a coin for the cutest doges on the internet"
        image_description: "cute dog with tongue out"

    The image_description will be used to create a token image.
    Please include ONE object that you think captures the essence of the memecoin, and attributes about that object.
    You want the object to be something that will cause potential investors to think of the memecoin.
    Avoid abstract or complex objects, try to explicitly describe your image.

    Do NOT launch a memecoin with a symbol that you already hold in your portfolio.
    Only launch a memecoin if it's different from the ones you already hold.

    This returns true if the memecoin was successfully launched, and false otherwise.

    Returns:
    - bool: A boolean indicating whether the memecoin was successfully launched.
    """
    # filter name to alphanumeric only, and only first 10 characters
    name = "".join([c for c in name[:10] if c.isalnum()])
    attributes = image_description + ", " + agent_interests.IMAGE_TAGS
    return crypto_connector.launch_memecoin(name, symbol, description, attributes)


@tool
def trade_coins(from_address: str, to_address: str, dollar_amount: float) -> bool:
    """
    Trades the specified amount of USD from one coin to another.

    This function will SELL "from_address" token, and BUY "to_address" token.
    The amount is specified in USD, and the trade will be executed at the current market rate.

    One of "from_address" or "to_address" MUST be "USDC", as this is the base asset for trading.
    All other addresses should be their respective token addresses, e.g. 0x60e860b7e30ad77a8b42192cd0e798783195f2ab

    Be careful with this, as it will trade real money. Only use it when you are sure you want to make the trade.

    Always trade small amounts, like 1-5% (or even less) of your portfolio. You don't want to lose all your money.

    You're limited to trading at most $50 at once. Please do not trade more than this.

    Parameters:
    - from_address (str): The address of the coin to trade from
    - to_address (str): The address of the coin to trade to
    - dollar_amount (float): The amount of USD to trade

    Returns:
    - bool: True if the trade was successful, False otherwise
    """
    try:
        return crypto_connector.trade(from_address, to_address, dollar_amount)
    except Exception:
        traceback.print_exc()
        return False
