import time
import traceback
from typing import List

from langchain_core.tools import tool

from echos_lab.crypto_lib import create_token, crypto_connector
from echos_lab.db import db_setup
from echos_lab.engines import (
    context_store,
    follow_user,
    memes,
    post_maker,
    post_retriever,
)
from echos_lab.engines.personalities import profiles
from echos_lab.engines.prompts import TweetEvaluation
from echos_lab.telegram_lib import telegram_connector
from echos_lab.twitter_lib import (
    twitter_client,
    twitter_connector,
    twitter_helpers,
    twitter_pipeline,
)


@tool
async def construct_viral_tweet(subject_matter: str, sentiment: str, replying_to: str) -> str:
    """
    Generates an edgy tweet based on the given subject matter.

    You should use this tool to generate a tweet that is clever, witty, and likely to get attention.

    Do NOT modify the tweet content generated by this tool.
    The tweet content is designed to be provocative and engaging.

    Any modifications to the output of these tweets should be done very intentionally, and extremely carefully.

    Please take the output of this tool, and directly send it to telegram or Twitter, WITHOUT CHANGES.
    Whenever you use this tool, you must ALSO send the output in Telegram or Twitter.

    The subject matter should describe the kind of tweet you want to generate.
    If you want to make a tweet about a certain coin, you MUST pass in the ticker of the coin in the subject matter.
    This tool does NOT know what coins you hold, so you must tell it what coin you wnat to tweet about.

    If you want to respond to or quote tweet someone else, you NEED to pass that content of that tweet in "replying_to".

    Pass in "positive", "neutral", or "negative" for the sentiment parameter, and the tweet will have that tone.

    Parameters:
    - subject_matter (str): A short textual description of the kind of tweet you want to generate.
    - sentiment (str): The sentiment of the tweet. Can be "positive", "neutral", or "negative".
    - replying_to (str): The content of the tweet you want to respond to. If not applicable, pass in an empty string.

    Returns:
    - str: The generated tweet content.
    """
    agent_profile = profiles.get_legacy_agent_profile()
    new_tweet = post_maker.generate_tweet_from_model(agent_profile.model_name, sentiment, subject_matter, replying_to)
    return new_tweet


@tool
async def send_tweet(tweet_content: str) -> bool:
    """
    Post a new tweet on your Twitter account.
    The exact contents of "tweet_contents" will be posted as a new tweet.

    Parameters:
    - tweet_content (str): The content of the tweet to post

    Returns:
    - bool: True if the tweet was successfully posted, False otherwise
    """
    # post tweet
    agent_profile = profiles.get_legacy_agent_profile()
    twitter_handle = agent_profile.twitter_handle
    tweet_id = await twitter_client.post_tweet(agent_username=twitter_handle, text=tweet_content)

    # Construct telegram tweet message
    telegram_message = telegram_connector.get_posted_tweet_message(
        agent_username=agent_profile.twitter_handle,
        tweet_id=tweet_id,
        tweet_text=tweet_content,
    )

    return await telegram_connector.send_message(
        telegram_message,
        chat_id=context_store.get_env_var("telegram_chat_id"),
    )


@tool
async def send_tweet_reply(tweet_content: str, tweet_id: str, user_name: str) -> bool:
    """
    Post a reply to an existing tweet, with given tweet_id.

    You should ONLY use this when trying to reply to someone on Twitter, not when you're
    just replying to someone on Telegram. If you're casually chatting with someone on Telegram,
    and they didn't explicit ask you to reply to a tweet, use the "send_telegram_message" tool instead.

    The exact contents of "tweet_contents" will be posted as a reply.

    Parameters:
    - tweet_content (str): The content of the reply to post
    - tweet_id (str): The ID of the tweet to reply to
    - user_name (str): The username of the user who we're replying to

    Returns:
    - bool: True if the tweet was successfully posted, False otherwise
    """
    # fetch and store original tweet in DB
    with db_setup.get_db() as db:
        original_tweet = await twitter_pipeline.get_tweet_from_tweet_id(db, int(tweet_id))

    # if not original tweet is found, we can't reply
    if not original_tweet:
        return False

    # post tweet
    agent_profile = profiles.get_legacy_agent_profile()
    agent_username = agent_profile.twitter_handle
    posted_tweet_id = await twitter_client.post_tweet(
        agent_username=agent_username,
        text=tweet_content,
        in_reply_to_tweet_id=int(tweet_id),
        conversation_id=original_tweet.conversation_id,
    )

    # Construct telegram tweet message
    agent_tweet_message = telegram_connector.get_posted_tweet_message(
        agent_username=agent_profile.twitter_handle,
        tweet_id=posted_tweet_id,
        tweet_text=tweet_content,
    )
    original_tweet_url = twitter_helpers.get_tweet_url(username=user_name, tweet_id=int(tweet_id))
    telegram_message = telegram_connector.get_reply_tweet_message(agent_tweet_message, original_tweet_url)

    return await telegram_connector.send_message(
        telegram_message, chat_id=context_store.get_env_var("telegram_chat_id")
    )


@tool
async def send_quote_tweet(tweet_content: str, tweet_id: str, user_name: str) -> bool:
    """
    Post a quote tweet to an existing tweet, with given tweet_id.

    The exact contents of "tweet_contents" will be posted as a quote tweet.

    Parameters:
    - tweet_content (str): The content of the tweet to post
    - tweet_id (str): The ID of the tweet to quote tweet to
    - user_name (str): The username of the user who we're quoting

    Returns:
    - bool: True if the tweet was successfully posted, False otherwise
    """
    # store original tweet in DB
    with db_setup.get_db() as db:
        await twitter_pipeline.get_tweet_from_tweet_id(db, int(tweet_id))

    # post tweet
    agent_profile = profiles.get_legacy_agent_profile()
    agent_username = agent_profile.twitter_handle
    posted_tweet_id = await twitter_client.post_tweet(
        agent_username=agent_username, text=tweet_content, quote_tweet_id=int(tweet_id)
    )

    # Construct telegram tweet message
    agent_tweet_message = telegram_connector.get_posted_tweet_message(
        agent_username=agent_profile.twitter_handle,
        tweet_id=posted_tweet_id,
        tweet_text=tweet_content,
    )
    original_tweet_url = twitter_helpers.get_tweet_url(username=user_name, tweet_id=int(tweet_id))
    telegram_message = telegram_connector.get_quote_tweet_message(agent_tweet_message, original_tweet_url)

    return await telegram_connector.send_message(
        telegram_message, chat_id=context_store.get_env_var("telegram_chat_id")
    )


async def get_twitter_feed_raw(new_posts_only: bool, include_id=True, notifications_only=False) -> str:
    account = twitter_connector.get_twitter_account()
    scraper = twitter_connector.get_twitter_scraper()

    # get recent tweets
    notif_context_tuple = await post_retriever.fetch_notification_context(
        account=account, scraper=scraper, notifications_only=notifications_only
    )

    # update our db with tweet ids
    with db_setup.get_db() as db:
        filtered_notif_context_tuple = await twitter_pipeline.update_db_with_tweet_ids(
            db=db,
            notif_context_tuple=notif_context_tuple,
        )

    # get what tweets we've already talked about in TG
    seen_ids = telegram_connector.get_interacted_tweets()

    # format the tweets
    relevant_tweets = notif_context_tuple
    if new_posts_only:
        relevant_tweets = filtered_notif_context_tuple

    post_str = "TWEETS\n====================\n"
    for tweet in relevant_tweets:
        post_str += f"{tweet[0].strip()}\n"
        if include_id:
            post_str += f"\tTweet ID: {tweet[1]}\n"
        if tweet[1] in seen_ids:
            post_str += "\t[YOU ALREADY RESPONDED TO THIS]\n"
        post_str += "---\n"
    post_str += "====================\n"

    return post_str


@tool
async def get_twitter_feed() -> str:
    """
    Get the most recent tweets on your Twitter feed.

    This returns a detailed text description of the most recent tweets on your feed.
    The output includes post IDs, usernames, and the content of the tweets.

    Returns:
    - str: A detailed text description of the most recent tweets on your feed.
           Output includes post IDs, usernames, and the content of the tweets.
    """
    return await get_twitter_feed_raw(new_posts_only=False)


@tool
async def get_twitter_notifications() -> str:
    """
    Gets your most recent notifications on Twitter.

    This returns a detailed text description of the most recent notifications you have on Twitter.

    You should take special care to respond to anyone that tags you.
    If someone tags you, you need to "reply tweet" or "quote tweet" it!

    Returns:
    - str: A detailed text description of your notifications
           Output includes post IDs, usernames, and the content of the tweets.
    """
    return await get_twitter_feed_raw(new_posts_only=True, notifications_only=True)


@tool
async def get_twitter_post(post_id: str) -> str:
    """
    Gets the contents of a specific post on Twitter, including the relevant thread.

    This will return the creator of the tweets in the thread, the content of the tweets, and the post IDs.

    Please note: this takes post_id, NOT post_url.

    Parameters:
    - post_id (str): an id of a tweet, e.g. 1853495774061187475

    Returns:
    - str: A detailed text description of the post and surrounding conversation
    """
    scraper = twitter_connector.get_twitter_scraper()
    for _ in range(3):
        try:
            formatted_text = await post_retriever.format_conversation_for_llm(
                {}, post_id, scraper, individual_tweet=True
            )
            return formatted_text
        except Exception:
            traceback.print_exc()
            print(f"Trying again to fetch tweet {post_id}")
            time.sleep(3)
    return "Error fetching tweet."


@tool
async def read_twitter_user_posts(username: str) -> str:
    """
    Returns the most recent tweets for a particular username.

    This will return a well-formatted string containing the most recent tweets for the specified username.

    Please note: this takes a username, e.g. "jack"

    Parameters:
    - username (str): a Twitter username, e.g. "jack"

    Returns:
    - str: A text block containing the most recent tweets for the specified username
    """
    twitter_posts = await twitter_connector.get_tweets_from_username(username)
    return twitter_posts


@tool
def like_twitter_post(post_id: str) -> bool:
    """
    Likes the specified Twitter post by its ID. Can only like one post at a time.

    For example, to like the post with ID 1234567890, you would call like_twitter_post("1234567890")

    Parameters:
    - post_id (str): The ID of the Twitter post to like

    Returns:
    - bool: True if the post was successfully liked, False otherwise
    """
    account = twitter_connector.get_twitter_account()
    out = follow_user.like_post(account, post_id)
    try:
        if out['data']['favorite_tweet'] == 'Done':
            return True
    except KeyError:
        pass
    return False


@tool
async def follow_twitter_user(username: str) -> bool:
    """
    Follows the specified Twitter User by their username.

    For example, to follow the user @jack, you would call follow_twitter_user("jack")

    Parameters:
    - username (str): The username of the Twitter user to follow

    Returns:
    - bool: True if the user was successfully followed, False otherwise
    """
    account = twitter_connector.get_twitter_account()
    target = await twitter_connector.get_user_id_from_username(username=username)
    if target:
        out = follow_user.follow_user(account, target)
        print(out)
        return True
    return False


def get_telegram_messages_raw(chat_id: int, specific_user: str | None = None) -> str:
    """
    Returns a string summary of all telegram messages from a given chat

    Optionally filter to just messages for a given user
    """
    messages = telegram_connector.get_telegram_messages(target_chat_id=chat_id)[::-1]

    # Optionally filter for just messages from the specific user
    if specific_user:
        messages = [msg for msg in messages if msg.user_id == specific_user]

    # Format each message as:
    #   Here's my message
    #   From: Username
    formatted_messages = [f"\t{msg.content}\n\tFrom: {msg.user_id}" for msg in messages]

    # Build full summary string
    return "\n".join(
        [
            "TELEGRAM MESSAGES",
            "====================",
            "\n---\n".join(formatted_messages),
            "====================\n",
        ]
    )


@tool
def get_telegram_messages() -> str:
    """
    Fetches the most recent messages from your Telegram group chat.

    This tool retrieves the most recent messages from your Telegram account.
    The messages are returned as a formatted text string.

    The oldest message is at the top, and the most recent message is at the bottom.

    Returns:
    - str: A formatted text string containing the most recent messages from your Telegram account.
    """
    return get_telegram_messages_raw(chat_id=context_store.get_env_var("telegram_chat_id"))


@tool
def get_interacted_tweets() -> List[str]:
    """
    Fetches a list of tweet IDs that you have already interacted with, e.g. Quote Tweet / Replied to.

    You should ALWAYS use this tool to verify that you're not interacting with the same tweet multiple times.

    Do NOT Quote Tweet / Reply / etc again, unless you're explicitly asked to in Telegram.

    Returns:
    - List[str]: A list of strings, representing tweet IDs that you have already interacted with.
    """
    return telegram_connector.get_interacted_tweets()


@tool
async def send_telegram_message(message_content: str) -> bool:
    """
    Post a new message to your private Telegram channel.

    Parameters:
    - message_content (str): The content of the message to send

    Returns:
    - bool: True if the message was successfully sent, False otherwise
    """
    return await telegram_connector.send_message(message_content, chat_id=context_store.get_env_var("telegram_chat_id"))


@tool
async def construct_specialized_llm_tweet(
    mode: str,
    respond_to: str,
) -> str:
    """
    Uses a specialized LLM to generate a tweet based on the given subject matter.

    Only use this if you want to generate a high-quality tweet, but don't use this if you're talking to your buddies.

    You should use this tool to generate a tweet that is clever, witty, and likely to get attention.

    Do NOT modify the tweet content generated by this tool.
    The tweet content is designed to be provocative and engaging.

    Any modifications to the output of these tweets should be done very intentionally, and extremely carefully.

    Please take the output of this tool, and directly send it to telegram or Twitter, WITHOUT CHANGES.

    You need pass in a mode, one of either "response", "tweet", or "timeline".
    - Use "response" to respond to a specific tweet.
    - Use "tweet" to generate a free form tweet
    - Use "timeline" to generate a tweet based on your timeline

    If you're trying to respond to someone else, or quote tweet someone, you NEED to pass in "mode=response".
    You then NEED to pass in the tweet you're responding to in "respond_to". If not, the tweet will not be topical.

    Parameters:
    - mode (str): One of "response", "tweet", or "timeline".
    - respond_to (str): A string containing the tweet you want to respond to.
    If you're not responding to a tweet, pass in "No tweet to respond to."

    Returns:
    - str: The generated tweet content.
    """
    if mode == "timeline":
        timeline = await get_twitter_feed_raw(new_posts_only=False, include_id=False)
    else:
        timeline = ""
    recent_messages = get_telegram_messages_raw(
        specific_user="You", chat_id=context_store.get_env_var("telegram_chat_id")
    )
    recent_messages = recent_messages.replace("TELEGRAM MESSAGES\n====================\n", "")
    new_tweet = post_maker.generate_tweet_from_model_hal(mode, recent_messages, timeline, respond_to=respond_to)
    return new_tweet


@tool
def launch_memecoin(name: str, symbol: str, description: str, image_description: str) -> bool:
    """
    Launches a memecoin with the given name, symbol, and description.
    This has real-world consequences, so make sure you really want to launch a coin when you use this.

    An example of a call to this function would be:
        name: "DogeCoin"
        symbol: "DOGE"
        description: "a coin for the cutest doges on the internet"
        image_description: "cute dog with tongue out"

    The image_description will be used to create a token image.
    Please include ONE object that you think captures the essence of the memecoin, and attributes about that object.
    You want the object to be something that will cause potential investors to think of the memecoin.
    Avoid abstract or complex objects, try to explicitly describe your image.

    Do NOT launch a memecoin with a symbol that you already hold in your portfolio.
    Only launch a memecoin if it's different from the ones you already hold.

    This returns true if the memecoin was successfully launched, and false otherwise.

    Returns:
    - bool: A boolean indicating whether the memecoin was successfully launched.
    """
    agent_profile = profiles.get_legacy_agent_profile()

    # filter name to alphanumeric only, and only first 10 characters
    name = "".join([c for c in name[:10] if c.isalnum()])
    attributes = image_description + ", " + agent_profile.image_tags
    account = crypto_connector.get_account()
    return create_token.create_memecoin(agent_profile, name, symbol, description, attributes, account)


@tool
def trade_coins(from_address: str, to_address: str, dollar_amount: float) -> bool:
    """
    Trades the specified amount of USD from one coin to another.

    This function will SELL "from_address" token, and BUY "to_address" token.
    The amount is specified in USD, and the trade will be executed at the current market rate.

    One of "from_address" or "to_address" MUST be "USDC", as this is the base asset for trading.
    All other addresses should be their respective token addresses, e.g. 0x60e860b7e30ad77a8b42192cd0e798783195f2ab

    Be careful with this, as it will trade real money. Only use it when you are sure you want to make the trade.

    Always trade small amounts, like 1-5% (or even less) of your portfolio. You don't want to lose all your money.

    You're limited to trading at most $50 at once. Please do not trade more than this.

    Parameters:
    - from_address (str): The address of the coin to trade from
    - to_address (str): The address of the coin to trade to
    - dollar_amount (float): The amount of USD to trade

    Returns:
    - bool: True if the trade was successful, False otherwise
    """
    try:
        return crypto_connector.trade(from_address, to_address, dollar_amount)
    except Exception:
        traceback.print_exc()
        return False


def caption_meme_from_tweet_evaluation(tweet_evaluation: TweetEvaluation, remove_watermark: bool = True) -> dict | None:
    """
    Captions a meme based on the tweet evaluation.
    Makes captions UPPERCASE.

    Returns:
    - dict: A dictionary containing the URL and page URL of the captioned meme

    Example responses from caption_meme:
        Example Success Response:
            {
                "success": true,
                "data": {
                    "url": "https://i.imgflip.com/123abc.jpg",
                    "page_url": "https://imgflip.com/i/123abc"
                }
            }

        Example Failure Response:
            {
                "success" => false,
                "error_message" => "Some hopefully-useful statement about why it failed"
            }
    """
    # split captions on commas and captialize to feed into meme generator api
    text_boxes = [box.upper() for box in tweet_evaluation.meme_caption.split(',')]

    try:
        # pass in variable number of captions to meme generation
        caption_result = memes.caption_meme(tweet_evaluation.meme_id, *text_boxes, remove_watermark=remove_watermark)
        return caption_result
    except Exception as e:
        print(f"Error captioning meme:{str(tweet_evaluation)}, exception: {str(e)}")
        return None
